package main

import (
	"flag"
	"fmt"
	"go/ast"
	"os"
	"strings"

	"github.com/tony2001/go-list-func"
	"golang.org/x/tools/go/packages"
)

func main() {
	var (
		private          bool
		printPackage     bool
		includeTests     bool
		includeGenerated bool
		verbose          bool
	)

	flag.BoolVar(&includeTests, "include-tests", false, "include tests")
	flag.BoolVar(&includeGenerated, "include-generated", false, "include generated files")
	flag.BoolVar(&private, "private", false, "also print non-exported funcs")
	flag.BoolVar(&printPackage, "print-package", false, "print package name for each function")
	flag.BoolVar(&verbose, "verbose", false, "print func names with args, return values and receivers")
	flag.Parse()

	pkgs, err := list.LoadPackages(flag.Args(), includeTests)
	if err != nil {
		fmt.Fprintf(os.Stderr, "LoadPackages(): %v\n", err)
		os.Exit(1)
	}

	applyFunc := func(pkg *packages.Package, file *ast.File, decl *ast.FuncDecl) error {
		if !includeGenerated && isGeneratedFile(file) {
			return nil
		}

		pkgName := ""
		if printPackage {
			pkgName = pkg.PkgPath
		}

		return printFuncDecl(pkgName, decl, verbose, private)
	}

	if err = list.WalkFuncs(pkgs, applyFunc); err != nil {
		fmt.Fprintf(os.Stderr, "WalkFuncs(): %v\n", err)
		os.Exit(1)
	}
}

func printFuncDecl(pkgName string, decl *ast.FuncDecl, verbose, private bool) error {
	if private || list.IsExported(decl) {
		if verbose {
			fmt.Println(list.FormatFuncDeclVerbose(pkgName, decl))
		} else {
			fmt.Println(list.FormatFuncDecl(pkgName, decl))
		}
	}

	return nil
}

// check if it's a generated file
func isGeneratedFile(file *ast.File) bool {
	const lookupStr1 = "code generated by" // keep this string lower-cased
	const lookupStr2 = "do not edit"       // and this one either

	for _, commentsGroup := range file.Comments {
		for _, comment := range commentsGroup.List {
			if len(comment.Text) < len(lookupStr1) {
				continue
			}

			lowerComment := strings.ToLower(comment.Text)
			if strings.Contains(lowerComment, lookupStr1) &&
				strings.Contains(lowerComment, lookupStr2) {
				return true
			}
		}
	}

	return false
}
